import {
  require_picomatch
} from "./chunk-Q2NKTHLO.js";
import {
  require_fs
} from "./chunk-OZKJN2R4.js";
import {
  require_path
} from "./chunk-37LIWE2Q.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-HMQSRIS3.js";

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:module
var require_node_module = __commonJS({
  "browser-external:node:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:module" has been externalized for browser compatibility. Cannot access "node:module.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:crypto
var require_node_crypto = __commonJS({
  "browser-external:node:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:crypto" has been externalized for browser compatibility. Cannot access "node:crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/fdir/dist/utils.js
var require_utils = __commonJS({
  "node_modules/fdir/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizePath = exports.isRootDirectory = exports.convertSlashes = exports.cleanPath = void 0;
    var path_1 = require_path();
    function cleanPath(path2) {
      let normalized = (0, path_1.normalize)(path2);
      if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)
        normalized = normalized.substring(0, normalized.length - 1);
      return normalized;
    }
    exports.cleanPath = cleanPath;
    var SLASHES_REGEX = /[\\/]/g;
    function convertSlashes(path2, separator) {
      return path2.replace(SLASHES_REGEX, separator);
    }
    exports.convertSlashes = convertSlashes;
    var WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
    function isRootDirectory(path2) {
      return path2 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path2);
    }
    exports.isRootDirectory = isRootDirectory;
    function normalizePath(path2, options) {
      const { resolvePaths, normalizePath: normalizePath2, pathSeparator } = options;
      const pathNeedsCleaning = process.platform === "win32" && path2.includes("/") || path2.startsWith(".");
      if (resolvePaths)
        path2 = (0, path_1.resolve)(path2);
      if (normalizePath2 || pathNeedsCleaning)
        path2 = cleanPath(path2);
      if (path2 === ".")
        return "";
      const needsSeperator = path2[path2.length - 1] !== pathSeparator;
      return convertSlashes(needsSeperator ? path2 + pathSeparator : path2, pathSeparator);
    }
    exports.normalizePath = normalizePath;
  }
});

// node_modules/fdir/dist/api/functions/join-path.js
var require_join_path = __commonJS({
  "node_modules/fdir/dist/api/functions/join-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = exports.joinDirectoryPath = exports.joinPathWithBasePath = void 0;
    var path_1 = require_path();
    var utils_1 = require_utils();
    function joinPathWithBasePath(filename, directoryPath) {
      return directoryPath + filename;
    }
    exports.joinPathWithBasePath = joinPathWithBasePath;
    function joinPathWithRelativePath(root, options) {
      return function(filename, directoryPath) {
        const sameRoot = directoryPath.startsWith(root);
        if (sameRoot)
          return directoryPath.replace(root, "") + filename;
        else
          return (0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
      };
    }
    function joinPath(filename) {
      return filename;
    }
    function joinDirectoryPath(filename, directoryPath, separator) {
      return directoryPath + filename + separator;
    }
    exports.joinDirectoryPath = joinDirectoryPath;
    function build(root, options) {
      const { relativePaths, includeBasePath } = options;
      return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/push-directory.js
var require_push_directory = __commonJS({
  "node_modules/fdir/dist/api/functions/push-directory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    function pushDirectoryWithRelativePath(root) {
      return function(directoryPath, paths) {
        paths.push(directoryPath.substring(root.length) || ".");
      };
    }
    function pushDirectoryFilterWithRelativePath(root) {
      return function(directoryPath, paths, filters) {
        const relativePath = directoryPath.substring(root.length) || ".";
        if (filters.every((filter) => filter(relativePath, true))) {
          paths.push(relativePath);
        }
      };
    }
    var pushDirectory = (directoryPath, paths) => {
      paths.push(directoryPath || ".");
    };
    var pushDirectoryFilter = (directoryPath, paths, filters) => {
      const path2 = directoryPath || ".";
      if (filters.every((filter) => filter(path2, true))) {
        paths.push(path2);
      }
    };
    var empty = () => {
    };
    function build(root, options) {
      const { includeDirs, filters, relativePaths } = options;
      if (!includeDirs)
        return empty;
      if (relativePaths)
        return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
      return filters && filters.length ? pushDirectoryFilter : pushDirectory;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/push-file.js
var require_push_file = __commonJS({
  "node_modules/fdir/dist/api/functions/push-file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var pushFileFilterAndCount = (filename, _paths, counts, filters) => {
      if (filters.every((filter) => filter(filename, false)))
        counts.files++;
    };
    var pushFileFilter = (filename, paths, _counts, filters) => {
      if (filters.every((filter) => filter(filename, false)))
        paths.push(filename);
    };
    var pushFileCount = (_filename, _paths, counts, _filters) => {
      counts.files++;
    };
    var pushFile = (filename, paths) => {
      paths.push(filename);
    };
    var empty = () => {
    };
    function build(options) {
      const { excludeFiles, filters, onlyCounts } = options;
      if (excludeFiles)
        return empty;
      if (filters && filters.length) {
        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
      } else if (onlyCounts) {
        return pushFileCount;
      } else {
        return pushFile;
      }
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/get-array.js
var require_get_array = __commonJS({
  "node_modules/fdir/dist/api/functions/get-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var getArray = (paths) => {
      return paths;
    };
    var getArrayGroup = () => {
      return [""].slice(0, 0);
    };
    function build(options) {
      return options.group ? getArrayGroup : getArray;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/group-files.js
var require_group_files = __commonJS({
  "node_modules/fdir/dist/api/functions/group-files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var groupFiles = (groups, directory, files) => {
      groups.push({ directory, files, dir: directory });
    };
    var empty = () => {
    };
    function build(options) {
      return options.group ? groupFiles : empty;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/resolve-symlink.js
var require_resolve_symlink = __commonJS({
  "node_modules/fdir/dist/api/functions/resolve-symlink.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var fs_1 = __importDefault(require_fs());
    var path_1 = require_path();
    var resolveSymlinksAsync = function(path2, state, callback) {
      const { queue, options: { suppressErrors } } = state;
      queue.enqueue();
      fs_1.default.realpath(path2, (error, resolvedPath) => {
        if (error)
          return queue.dequeue(suppressErrors ? null : error, state);
        fs_1.default.stat(resolvedPath, (error2, stat) => {
          if (error2)
            return queue.dequeue(suppressErrors ? null : error2, state);
          if (stat.isDirectory() && isRecursive(path2, resolvedPath, state))
            return queue.dequeue(null, state);
          callback(stat, resolvedPath);
          queue.dequeue(null, state);
        });
      });
    };
    var resolveSymlinks = function(path2, state, callback) {
      const { queue, options: { suppressErrors } } = state;
      queue.enqueue();
      try {
        const resolvedPath = fs_1.default.realpathSync(path2);
        const stat = fs_1.default.statSync(resolvedPath);
        if (stat.isDirectory() && isRecursive(path2, resolvedPath, state))
          return;
        callback(stat, resolvedPath);
      } catch (e) {
        if (!suppressErrors)
          throw e;
      }
    };
    function build(options, isSynchronous) {
      if (!options.resolveSymlinks || options.excludeSymlinks)
        return null;
      return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
    }
    exports.build = build;
    function isRecursive(path2, resolved, state) {
      if (state.options.useRealPaths)
        return isRecursiveUsingRealPaths(resolved, state);
      let parent = (0, path_1.dirname)(path2);
      let depth = 1;
      while (parent !== state.root && depth < 2) {
        const resolvedPath = state.symlinks.get(parent);
        const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
        if (isSameRoot)
          depth++;
        else
          parent = (0, path_1.dirname)(parent);
      }
      state.symlinks.set(path2, resolved);
      return depth > 1;
    }
    function isRecursiveUsingRealPaths(resolved, state) {
      return state.visited.includes(resolved + state.options.pathSeparator);
    }
  }
});

// node_modules/fdir/dist/api/functions/invoke-callback.js
var require_invoke_callback = __commonJS({
  "node_modules/fdir/dist/api/functions/invoke-callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var onlyCountsSync = (state) => {
      return state.counts;
    };
    var groupsSync = (state) => {
      return state.groups;
    };
    var defaultSync = (state) => {
      return state.paths;
    };
    var limitFilesSync = (state) => {
      return state.paths.slice(0, state.options.maxFiles);
    };
    var onlyCountsAsync = (state, error, callback) => {
      report(error, callback, state.counts, state.options.suppressErrors);
      return null;
    };
    var defaultAsync = (state, error, callback) => {
      report(error, callback, state.paths, state.options.suppressErrors);
      return null;
    };
    var limitFilesAsync = (state, error, callback) => {
      report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
      return null;
    };
    var groupsAsync = (state, error, callback) => {
      report(error, callback, state.groups, state.options.suppressErrors);
      return null;
    };
    function report(error, callback, output, suppressErrors) {
      if (error && !suppressErrors)
        callback(error, output);
      else
        callback(null, output);
    }
    function build(options, isSynchronous) {
      const { onlyCounts, group, maxFiles } = options;
      if (onlyCounts)
        return isSynchronous ? onlyCountsSync : onlyCountsAsync;
      else if (group)
        return isSynchronous ? groupsSync : groupsAsync;
      else if (maxFiles)
        return isSynchronous ? limitFilesSync : limitFilesAsync;
      else
        return isSynchronous ? defaultSync : defaultAsync;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/functions/walk-directory.js
var require_walk_directory = __commonJS({
  "node_modules/fdir/dist/api/functions/walk-directory.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.build = void 0;
    var fs_1 = __importDefault(require_fs());
    var readdirOpts = { withFileTypes: true };
    var walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {
      state.queue.enqueue();
      if (currentDepth < 0)
        return state.queue.dequeue(null, state);
      state.visited.push(crawlPath);
      state.counts.directories++;
      fs_1.default.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
        callback(entries, directoryPath, currentDepth);
        state.queue.dequeue(state.options.suppressErrors ? null : error, state);
      });
    };
    var walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {
      if (currentDepth < 0)
        return;
      state.visited.push(crawlPath);
      state.counts.directories++;
      let entries = [];
      try {
        entries = fs_1.default.readdirSync(crawlPath || ".", readdirOpts);
      } catch (e) {
        if (!state.options.suppressErrors)
          throw e;
      }
      callback(entries, directoryPath, currentDepth);
    };
    function build(isSynchronous) {
      return isSynchronous ? walkSync : walkAsync;
    }
    exports.build = build;
  }
});

// node_modules/fdir/dist/api/queue.js
var require_queue = __commonJS({
  "node_modules/fdir/dist/api/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Queue = void 0;
    var Queue = class {
      constructor(onQueueEmpty) {
        __publicField(this, "onQueueEmpty");
        __publicField(this, "count", 0);
        this.onQueueEmpty = onQueueEmpty;
      }
      enqueue() {
        this.count++;
        return this.count;
      }
      dequeue(error, output) {
        if (this.onQueueEmpty && (--this.count <= 0 || error)) {
          this.onQueueEmpty(error, output);
          if (error) {
            output.controller.abort();
            this.onQueueEmpty = void 0;
          }
        }
      }
    };
    exports.Queue = Queue;
  }
});

// node_modules/fdir/dist/api/counter.js
var require_counter = __commonJS({
  "node_modules/fdir/dist/api/counter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Counter = void 0;
    var Counter = class {
      constructor() {
        __publicField(this, "_files", 0);
        __publicField(this, "_directories", 0);
      }
      set files(num) {
        this._files = num;
      }
      get files() {
        return this._files;
      }
      set directories(num) {
        this._directories = num;
      }
      get directories() {
        return this._directories;
      }
      /**
       * @deprecated use `directories` instead
       */
      /* c8 ignore next 3 */
      get dirs() {
        return this._directories;
      }
    };
    exports.Counter = Counter;
  }
});

// node_modules/fdir/dist/api/walker.js
var require_walker = __commonJS({
  "node_modules/fdir/dist/api/walker.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Walker = void 0;
    var path_1 = require_path();
    var utils_1 = require_utils();
    var joinPath = __importStar(require_join_path());
    var pushDirectory = __importStar(require_push_directory());
    var pushFile = __importStar(require_push_file());
    var getArray = __importStar(require_get_array());
    var groupFiles = __importStar(require_group_files());
    var resolveSymlink = __importStar(require_resolve_symlink());
    var invokeCallback = __importStar(require_invoke_callback());
    var walkDirectory = __importStar(require_walk_directory());
    var queue_1 = require_queue();
    var counter_1 = require_counter();
    var Walker = class {
      constructor(root, options, callback) {
        __publicField(this, "root");
        __publicField(this, "isSynchronous");
        __publicField(this, "state");
        __publicField(this, "joinPath");
        __publicField(this, "pushDirectory");
        __publicField(this, "pushFile");
        __publicField(this, "getArray");
        __publicField(this, "groupFiles");
        __publicField(this, "resolveSymlink");
        __publicField(this, "walkDirectory");
        __publicField(this, "callbackInvoker");
        __publicField(this, "walk", (entries, directoryPath, depth) => {
          const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
          if (controller.signal.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles)
            return;
          const files = this.getArray(this.state.paths);
          for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks) {
              const filename = this.joinPath(entry.name, directoryPath);
              this.pushFile(filename, files, this.state.counts, filters);
            } else if (entry.isDirectory()) {
              let path2 = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
              if (exclude && exclude(entry.name, path2))
                continue;
              this.pushDirectory(path2, paths, filters);
              this.walkDirectory(this.state, path2, path2, depth - 1, this.walk);
            } else if (this.resolveSymlink && entry.isSymbolicLink()) {
              let path2 = joinPath.joinPathWithBasePath(entry.name, directoryPath);
              this.resolveSymlink(path2, this.state, (stat, resolvedPath) => {
                if (stat.isDirectory()) {
                  resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
                  if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path2 + pathSeparator))
                    return;
                  this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path2 + pathSeparator, depth - 1, this.walk);
                } else {
                  resolvedPath = useRealPaths ? resolvedPath : path2;
                  const filename = (0, path_1.basename)(resolvedPath);
                  const directoryPath2 = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);
                  resolvedPath = this.joinPath(filename, directoryPath2);
                  this.pushFile(resolvedPath, files, this.state.counts, filters);
                }
              });
            }
          }
          this.groupFiles(this.state.groups, directoryPath, files);
        });
        this.isSynchronous = !callback;
        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
        this.root = (0, utils_1.normalizePath)(root, options);
        this.state = {
          root: (0, utils_1.isRootDirectory)(this.root) ? this.root : this.root.slice(0, -1),
          // Perf: we explicitly tell the compiler to optimize for String arrays
          paths: [""].slice(0, 0),
          groups: [],
          counts: new counter_1.Counter(),
          options,
          queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),
          symlinks: /* @__PURE__ */ new Map(),
          visited: [""].slice(0, 0),
          controller: new AbortController()
        };
        this.joinPath = joinPath.build(this.root, options);
        this.pushDirectory = pushDirectory.build(this.root, options);
        this.pushFile = pushFile.build(options);
        this.getArray = getArray.build(options);
        this.groupFiles = groupFiles.build(options);
        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
        this.walkDirectory = walkDirectory.build(this.isSynchronous);
      }
      start() {
        this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
      }
    };
    exports.Walker = Walker;
  }
});

// node_modules/fdir/dist/api/async.js
var require_async = __commonJS({
  "node_modules/fdir/dist/api/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callback = exports.promise = void 0;
    var walker_1 = require_walker();
    function promise(root, options) {
      return new Promise((resolve, reject) => {
        callback(root, options, (err, output) => {
          if (err)
            return reject(err);
          resolve(output);
        });
      });
    }
    exports.promise = promise;
    function callback(root, options, callback2) {
      let walker = new walker_1.Walker(root, options, callback2);
      walker.start();
    }
    exports.callback = callback;
  }
});

// node_modules/fdir/dist/api/sync.js
var require_sync = __commonJS({
  "node_modules/fdir/dist/api/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sync = void 0;
    var walker_1 = require_walker();
    function sync(root, options) {
      const walker = new walker_1.Walker(root, options);
      return walker.start();
    }
    exports.sync = sync;
  }
});

// node_modules/fdir/dist/builder/api-builder.js
var require_api_builder = __commonJS({
  "node_modules/fdir/dist/builder/api-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APIBuilder = void 0;
    var async_1 = require_async();
    var sync_1 = require_sync();
    var APIBuilder = class {
      constructor(root, options) {
        __publicField(this, "root");
        __publicField(this, "options");
        this.root = root;
        this.options = options;
      }
      withPromise() {
        return (0, async_1.promise)(this.root, this.options);
      }
      withCallback(cb) {
        (0, async_1.callback)(this.root, this.options, cb);
      }
      sync() {
        return (0, sync_1.sync)(this.root, this.options);
      }
    };
    exports.APIBuilder = APIBuilder;
  }
});

// node_modules/fdir/dist/builder/index.js
var require_builder = __commonJS({
  "node_modules/fdir/dist/builder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Builder = void 0;
    var path_1 = require_path();
    var api_builder_1 = require_api_builder();
    var pm = null;
    try {
      __require.resolve("picomatch");
      pm = require_picomatch();
    } catch (_e) {
    }
    var Builder = class {
      constructor(options) {
        __publicField(this, "globCache", {});
        __publicField(this, "options", {
          maxDepth: Infinity,
          suppressErrors: true,
          pathSeparator: path_1.sep,
          filters: []
        });
        __publicField(this, "globFunction");
        this.options = { ...this.options, ...options };
        this.globFunction = this.options.globFunction;
      }
      group() {
        this.options.group = true;
        return this;
      }
      withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
      }
      withBasePath() {
        this.options.includeBasePath = true;
        return this;
      }
      withRelativePaths() {
        this.options.relativePaths = true;
        return this;
      }
      withDirs() {
        this.options.includeDirs = true;
        return this;
      }
      withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
      }
      withMaxFiles(limit) {
        this.options.maxFiles = limit;
        return this;
      }
      withFullPaths() {
        this.options.resolvePaths = true;
        this.options.includeBasePath = true;
        return this;
      }
      withErrors() {
        this.options.suppressErrors = false;
        return this;
      }
      withSymlinks({ resolvePaths = true } = {}) {
        this.options.resolveSymlinks = true;
        this.options.useRealPaths = resolvePaths;
        return this.withFullPaths();
      }
      withAbortSignal(signal) {
        this.options.signal = signal;
        return this;
      }
      normalize() {
        this.options.normalizePath = true;
        return this;
      }
      filter(predicate) {
        this.options.filters.push(predicate);
        return this;
      }
      onlyDirs() {
        this.options.excludeFiles = true;
        this.options.includeDirs = true;
        return this;
      }
      exclude(predicate) {
        this.options.exclude = predicate;
        return this;
      }
      onlyCounts() {
        this.options.onlyCounts = true;
        return this;
      }
      crawl(root) {
        return new api_builder_1.APIBuilder(root || ".", this.options);
      }
      withGlobFunction(fn) {
        this.globFunction = fn;
        return this;
      }
      /**
       * @deprecated Pass options using the constructor instead:
       * ```ts
       * new fdir(options).crawl("/path/to/root");
       * ```
       * This method will be removed in v7.0
       */
      /* c8 ignore next 4 */
      crawlWithOptions(root, options) {
        this.options = { ...this.options, ...options };
        return new api_builder_1.APIBuilder(root || ".", this.options);
      }
      glob(...patterns) {
        if (this.globFunction) {
          return this.globWithOptions(patterns);
        }
        return this.globWithOptions(patterns, ...[{ dot: true }]);
      }
      globWithOptions(patterns, ...options) {
        const globFn = this.globFunction || pm;
        if (!globFn) {
          throw new Error("Please specify a glob function to use glob matching.");
        }
        var isMatch = this.globCache[patterns.join("\0")];
        if (!isMatch) {
          isMatch = globFn(patterns, ...options);
          this.globCache[patterns.join("\0")] = isMatch;
        }
        this.options.filters.push((path2) => isMatch(path2));
        return this;
      }
    };
    exports.Builder = Builder;
  }
});

// node_modules/fdir/dist/types.js
var require_types = __commonJS({
  "node_modules/fdir/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/fdir/dist/index.js
var require_dist = __commonJS({
  "node_modules/fdir/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fdir = void 0;
    var builder_1 = require_builder();
    Object.defineProperty(exports, "fdir", { enumerable: true, get: function() {
      return builder_1.Builder;
    } });
    __exportStar(require_types(), exports);
  }
});

// node_modules/tinyglobby/dist/index.mjs
var import_path = __toESM(require_path(), 1);
var import_fdir = __toESM(require_dist(), 1);
var import_picomatch = __toESM(require_picomatch(), 1);
var ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;
function getPartialMatcher(patterns, options) {
  const patternsCount = patterns.length;
  const patternsParts = Array(patternsCount);
  const regexes = Array(patternsCount);
  for (let i = 0; i < patternsCount; i++) {
    const parts = splitPattern(patterns[i]);
    patternsParts[i] = parts;
    const partsCount = parts.length;
    const partRegexes = Array(partsCount);
    for (let j = 0; j < partsCount; j++) partRegexes[j] = import_picomatch.default.makeRe(parts[j], options);
    regexes[i] = partRegexes;
  }
  return (input) => {
    const inputParts = input.split("/");
    if (inputParts[0] === ".." && ONLY_PARENT_DIRECTORIES.test(input)) return true;
    for (let i = 0; i < patterns.length; i++) {
      const patternParts = patternsParts[i];
      const regex = regexes[i];
      const inputPatternCount = inputParts.length;
      const minParts = Math.min(inputPatternCount, patternParts.length);
      let j = 0;
      while (j < minParts) {
        const part = patternParts[j];
        if (part.includes("/")) return true;
        const match = regex[j].test(inputParts[j]);
        if (!match) break;
        if (part === "**") return true;
        j++;
      }
      if (j === inputPatternCount) return true;
    }
    return false;
  };
}
var splitPatternOptions = { parts: true };
function splitPattern(path$1) {
  var _result$parts;
  const result = import_picomatch.default.scan(path$1, splitPatternOptions);
  return ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$1];
}
var isWin = process.platform === "win32";
var POSIX_UNESCAPED_GLOB_SYMBOLS = new RegExp("(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))", "g");
var WIN32_UNESCAPED_GLOB_SYMBOLS = new RegExp("(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())", "g");
var escapePosixPath = (path$1) => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapeWin32Path = (path$1) => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
var escapePath = isWin ? escapeWin32Path : escapePosixPath;
function isDynamicPattern(pattern, options) {
  if ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;
  const scan = import_picomatch.default.scan(pattern);
  return scan.isGlob || scan.negated;
}
function log(...tasks) {
  console.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString("es")}]`, ...tasks);
}
var PARENT_DIRECTORY = /^(\/?\.\.)+/;
var ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
var BACKSLASHES = /\\/g;
function normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {
  let result = pattern;
  if (pattern.endsWith("/")) result = pattern.slice(0, -1);
  if (!result.endsWith("*") && expandDirectories) result += "/**";
  const escapedCwd = escapePath(cwd);
  if (import_path.default.isAbsolute(result.replace(ESCAPING_BACKSLASHES, ""))) result = import_path.posix.relative(escapedCwd, result);
  else result = import_path.posix.normalize(result);
  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
  const parts = splitPattern(result);
  if (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {
    const n = (parentDirectoryMatch[0].length + 1) / 3;
    let i = 0;
    const cwdParts = escapedCwd.split("/");
    while (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {
      result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || ".";
      i++;
    }
    const potentialRoot = import_path.posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));
    if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
      props.root = potentialRoot;
      props.depthOffset = -n + i;
    }
  }
  if (!isIgnore && props.depthOffset >= 0) {
    var _props$commonPath;
    (_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);
    const newCommonPath = [];
    const length = Math.min(props.commonPath.length, parts.length);
    for (let i = 0; i < length; i++) {
      const part = parts[i];
      if (part === "**" && !parts[i + 1]) {
        newCommonPath.pop();
        break;
      }
      if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;
      newCommonPath.push(part);
    }
    props.depthOffset = newCommonPath.length;
    props.commonPath = newCommonPath;
    props.root = newCommonPath.length > 0 ? import_path.default.posix.join(cwd, ...newCommonPath) : cwd;
  }
  return result;
}
function processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {
  if (typeof patterns === "string") patterns = [patterns];
  else if (!patterns) patterns = ["**/*"];
  if (typeof ignore === "string") ignore = [ignore];
  const matchPatterns = [];
  const ignorePatterns = [];
  for (const pattern of ignore) {
    if (!pattern) continue;
    if (pattern[0] !== "!" || pattern[1] === "(") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));
  }
  for (const pattern of patterns) {
    if (!pattern) continue;
    if (pattern[0] !== "!" || pattern[1] === "(") matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));
    else if (pattern[1] !== "!" || pattern[2] === "(") ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));
  }
  return {
    match: matchPatterns,
    ignore: ignorePatterns
  };
}
function getRelativePath(path$1, cwd, root) {
  return import_path.posix.relative(cwd, `${root}/${path$1}`) || ".";
}
function processPath(path$1, cwd, root, isDirectory, absolute) {
  const relativePath = absolute ? path$1.slice(root === "/" ? 1 : root.length + 1) || "." : path$1;
  if (root === cwd) return isDirectory && relativePath !== "." ? relativePath.slice(0, -1) : relativePath;
  return getRelativePath(relativePath, cwd, root);
}
function formatPaths(paths, cwd, root) {
  for (let i = paths.length - 1; i >= 0; i--) {
    const path$1 = paths[i];
    paths[i] = getRelativePath(path$1, cwd, root) + (!path$1 || path$1.endsWith("/") ? "/" : "");
  }
  return paths;
}
function crawl(options, cwd, sync) {
  if (process.env.TINYGLOBBY_DEBUG) options.debug = true;
  if (options.debug) log("globbing with options:", options, "cwd:", cwd);
  if (Array.isArray(options.patterns) && options.patterns.length === 0) return sync ? [] : Promise.resolve([]);
  const props = {
    root: cwd,
    commonPath: null,
    depthOffset: 0
  };
  const processed = processPatterns(options, cwd, props);
  const nocase = options.caseSensitiveMatch === false;
  if (options.debug) log("internal processing patterns:", processed);
  const matcher = (0, import_picomatch.default)(processed.match, {
    dot: options.dot,
    nocase,
    ignore: processed.ignore
  });
  const ignore = (0, import_picomatch.default)(processed.ignore, {
    dot: options.dot,
    nocase
  });
  const partialMatcher = getPartialMatcher(processed.match, {
    dot: options.dot,
    nocase
  });
  const fdirOptions = {
    filters: [options.debug ? (p, isDirectory) => {
      const path$1 = processPath(p, cwd, props.root, isDirectory, options.absolute);
      const matches = matcher(path$1);
      if (matches) log(`matched ${path$1}`);
      return matches;
    } : (p, isDirectory) => matcher(processPath(p, cwd, props.root, isDirectory, options.absolute))],
    exclude: options.debug ? (_, p) => {
      const relativePath = processPath(p, cwd, props.root, true, true);
      const skipped = relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
      if (skipped) log(`skipped ${p}`);
      else log(`crawling ${p}`);
      return skipped;
    } : (_, p) => {
      const relativePath = processPath(p, cwd, props.root, true, true);
      return relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
    },
    pathSeparator: "/",
    relativePaths: true,
    resolveSymlinks: true
  };
  if (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);
  if (options.absolute) {
    fdirOptions.relativePaths = false;
    fdirOptions.resolvePaths = true;
    fdirOptions.includeBasePath = true;
  }
  if (options.followSymbolicLinks === false) {
    fdirOptions.resolveSymlinks = false;
    fdirOptions.excludeSymlinks = true;
  }
  if (options.onlyDirectories) {
    fdirOptions.excludeFiles = true;
    fdirOptions.includeDirs = true;
  } else if (options.onlyFiles === false) fdirOptions.includeDirs = true;
  props.root = props.root.replace(BACKSLASHES, "");
  const root = props.root;
  if (options.debug) log("internal properties:", props);
  const api = new import_fdir.fdir(fdirOptions).crawl(root);
  if (cwd === root || options.absolute) return sync ? api.sync() : api.withPromise();
  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));
}
async function glob(patternsOrOptions, options) {
  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error("Cannot pass patterns as both an argument and an option");
  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? {
    ...options,
    patterns: patternsOrOptions
  } : patternsOrOptions;
  const cwd = opts.cwd ? import_path.default.resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
  return crawl(opts, cwd, false);
}
function globSync(patternsOrOptions, options) {
  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error("Cannot pass patterns as both an argument and an option");
  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? {
    ...options,
    patterns: patternsOrOptions
  } : patternsOrOptions;
  const cwd = opts.cwd ? import_path.default.resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
  return crawl(opts, cwd, true);
}

export {
  require_node_url,
  require_node_module,
  require_node_crypto,
  require_dist,
  escapePath,
  isDynamicPattern,
  glob,
  globSync
};
//# sourceMappingURL=chunk-47LEJ6Y3.js.map
